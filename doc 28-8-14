
*********************************************************************************
an example tree for which iburg and Aho Jhonson gives diff cover's 
*********************************************************************************

the grammer goes as folows
-------------------------------------
%term OP=1 IND=2 CONST=3 MEMORY=4
%%
reg:	OP(reg,reg) = 1 (2) ;
reg:	IND(OP(reg,mem)) = 2 (4) ;
reg:	IND(reg) = 8 (1) ;
mem:	reg = 3 (1) ;
reg:	mem = 4 (1) ;
reg:	CONST = 5 (1) ;
reg:	MEMORY = 6 (1) ;
mem:	MEMORY = 7 (0) ;
%%
--------------------------------------

The tree for which instruction cover is generated is 


(+,
	(+,
		(+, a, b),
		(ind	(+, 1, 2))
	),
	(ind 	(+, c, d))
)


here numbers are CONST and all other variables are MEMORY.

--------------------------------------

The instruction cover generated by iburg is

reg: OP(reg,reg)
 reg: OP(reg,reg)
  reg: OP(reg,reg)
   reg: MEMORY
   reg: MEMORY
  reg: IND(reg)
   reg: OP(reg,reg)
    reg: CONST
    reg: CONST
 reg: IND(reg)
  reg: OP(reg,reg)
   reg: MEMORY
   reg: MEMORY

the code generated by this is

	r1 <- c
	r2 <- d
	r1 <- r1 + r2	
	r1 <- ind(r1)	\\ right subtree evaluated to r1

	r2 <- 1
	r3 <- 2
	r2 <- r2 + r3
	r2 <- ind(r2)	 code for ind(1+2)

	r3 <- a
	r4 <- b
	r3 <- r3 + r4	 code for a+b

	r2 <- r3 + r2	 left subtree evaluated to r2

	r1 <- r1 + r2


here 4 registers are used.

But if the number of available registers is only 2, Aho Jhonson's algorithm evaluates the subtree in this manner.


r1 <- a 			
r2 <- b
r1 <- r1 + r2
m1 <- r1			a + b stored to m1

r1 <- 1 
r2 <- 2
r1 <- r1 + r2		code for ind(1 + 2)

r1 <- ind(r1)
r2 <- m1			
r2 <- r2 + r1		left subtree evaluated to r2

r1 <- c 			
r1 <- ind(r1 + d)	right subtree evaluated to r2

r2 <- r2 + r1 		


*********************************************************************************
Plan of Implementation
*********************************************************************************

The target is
	Input:
		Total number of available registers
		Instruction tree grammar where for each instruction we have
			the insruction
			its identifying number
			its cost
			the number of registers it requires (assume minimum)
			the corresponding machine code to be generated
			and if required also the corresponding intermediate code.

	Output:
		Generate a CPP code that does the following
			takes in a tree of the above given grammer
			optimal instruction matching
			do Sethi Ullman numbering
			generate intermediate code and machine code based on optimal cover, SU numbering and register availability 


The output ".cpp" file will have the following major functions to do the above
	label(tree_node p)
	pick_best(tree_node p)
	number(tree_node p)
	gen_code(tree_node p)


And also generate integer codes for the non-terminals, and termials to index them furthur.


label(tree_node p):		//similar to iburg
-------------------
 
The goal of this is to generate a tree automaton and use pattern matching by to find all possible instructions at each node.

The state function of the automaton is like
			
		struct state {
			int op;
			struct state *left, *right;
			int cost[N];
			int rule[N];
		};

where 

op 		-	operator / the terminal at the root of the node.
left	-	pointer to left operand/subtree
right	-	pointer to right operand/subtree
N 		-	no of terminals in the original tree grammar
cost 	- 	cost[i] is the minimum cost for the tree rooted at this node to result in terminal i.
rule 	-	rule[i] is the instruction number which resulted in cost[i]


--> Every node in the subject tree given should be labeled with a state function.

--> to label a tree, the following helper functions are required
		- a list of all terminal symbols			Eg : ADDI, MEM, CONST
		- a list of all nonterminal symbols			Eg : stmt, reg, con, mem
		- closure functions. 						Eg : if an instruction results in a non terminal 'reg' and we have an 
													instruction  mem <- reg then by using the above two the subtree can 
													result in 'mem'. Closure fn's are required to establish all such instructions sets.

--> Leaves will be labelled first then for each subsequent node consider the operator at the node and the state labels at both operands to label it. 

--> labelling takes place in this manner
		- the left and right subtree pointers are assigned values
		- intialize all the values of cost array to INT_MAX and rule array to -1
		- from the 'op' of the node look for all the instructions that has the same 'op' as root
		- for each of these verify if the left and right subtree satisfy the choosen cover
		- if they do, then from the cost arrays of the children and the cost of the instruction, the resultant cost can be calculated
		- find the complete closure of the result of the instruction and fill the corresponding entry's in cost and rule array's.
		- do the same for all the possible instructions.


assume for a node the op = PLUS, the label function would look something like this

 label(op, left l, right r) {
	struct state *p;
	p = malloc(sizeof *p);
	p->op = op; 
	p->left = l; 
	p->right = r;
	p->rule[1] = ... = 0; p->cost[1] = ... = 32767;

	switch (op) {
		case PLUS:	
															reg = reg PLUS reg										
			if ( l->rule[reg] && r->rule[reg] ) 			checking if the subtrees can result in a register
			{			
				c = l->cost[reg] + r->cost[reg] + 1;
				
				// if the cost thus obtained is less than that already present update it
				// and then find closure of reg as the result above would end up in reg

			}
															reg = reg PLUS con
			if (l->rule[reg] && r->rule[con]) 				checking if the left and right subtree can result in a reg and con resp.
			{
				c = l->cost[reg] + r->cost[con] + 0;
				
				// if the cost thus obtained is less than that already present update it
				// and then find closure of reg as the result above would end up in reg

			}
			break;

		case MULT:
			
				...

		break;

		case MEM:
				
				...

		break;

		...
	}
	return
}




pick_best(tree_node p):		// partially taken from iburg
----------------------

A topdown scan now lets us generate the assembly instructions.

Some decode functions are used to decide which instruction eactly resulted in the non terminal.
And also some helper functions to skip to right childen in case of complex instruction covers like 'reg <- IND(a PLUS b)'

From the subject tree given as input we know where the result of root should end up in.
Pick the corresponding rule no (if it ends in reg, the rule[index(reg)] )
Based on the requirement of the same pick instructions from left and right subtree and from them 
do the same for all the subtrees passing them the non terminal they should result in from the parent
and picking the instructions that are to be generated at that node

By the end of this, we have at every node, the instructions it should generate.


number(tree_node p): 
--------------------

since we have the number of registers required for each instruction from the input
and now, we also have the optimal instruction cover, we number every node of the tree with number of registers required to generate code for it.

Do a bottom up traversal using recursion
At every node
	#reg's for a node = #reg's for itself + SethiUllmanCost(children)

SethiUllmanCost(node1, node2) =  max(node1,node2)  if #reg's(node1) != #reg's(node2)
								 node1 + 1		otherwise.

If at any node the # instructions exceed the available registers, mark it for storing it furthur, reset its required #reg's to 1
and proceed furthur.
By the end of this, we will have a numered tree.


gen_code(tree_node p):	
----------------------

Do an initial pass over the tree generating instructions for all those subtrees which need a store.
At the same time store at the root the memory location its result is stored in.

Now do a final pass and generate code for the rest of tree following the Sethi Ullman order of execution of subtrees.

_________________________________________________________________________________________________________


















