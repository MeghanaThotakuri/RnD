/****************************************************************************************
Input should contain
	Total number of available registers 
	Instruction tree grammar where for each instruction we have 
		the instruction 
		cost
		the corresponding machine code to be generated 

$$ - root
$1 - left subtree
$2 - right subtree
CON - integer constant
CONF - constant which is float
ADDR - variable
INT - integer typecast
FLOAT - float typecast


I have a list of all the values each of the non terminals can take.
Allotting them appropriately is the task of the c++ code
that we generate for code generation.

In the grammar, along with each rule, the operation it corresponds to and the parameters in the corresponding 
instruction are also given in the order they are to be printed in the instruction. 
ex {add, result, param1, param2} for "add $result, $param1, $prama2"


*****************************************************************************************/

%%	
\* Operators *\
	
	no_instruction
	load
	imm_load
	store
	sgt
	sge
	slt
	sle
  	seq
  	sne	
 	if_else
  	goto_type
  	add
  	sub
  	mul
  	div
  	uminus
  	move
  	load_d 
	imm_load_d
	store_d
	add_d
  	sub_d
  	mul_d
  	div_d
  	move_d
  	mtc1
  	mfc1
  	uminus_d

%%
/*
	Operator : assembly_format, assembly_mnemonic 
assembly formats ::
	op,				/* Only the operator, no operand */
	op_r,			/* No operands, eg. goto L */
	op_r_o1,		/* One operand, eg. op r, o1 */
	op_r_o1_o2,		/* Two operands, eg. op r, o1, o2 */ 
	op_nsy			/* not specified yet */

*/
	no_instruction  =	op_nsy, -
	load =    			op_r_o1, lw
	imm_load =		    op_r_o1, li
	store =  			op_r_o1, sw
	sgt =    			op_r_o1_o2, sgt
	sge =    			op_r_o1_o2, sge
	slt =    			op_r_o1_o2, slt
	sle =    			op_r_o1_o2, sle
	seq =    			op_r_o1_o2, seq
	sne =    			op_r_o1_o2, sne
	if_else =    		op_r_o1_o2, bne
	goto_type =    		op_r, j
	add =    			op_r_o1_o2, add
	sub =    			op_r_o1_o2, sub
	mul =    			op_r_o1_o2, mul
	div =    			op_r_o1_o2, div
	uminus =    		op_r_o1, neg
	move =    			op_r_o1, mv
	load_d =    		op_r_o1, lw.d
	imm_load_d =    	op_r_o1, li.d
	store_d =    		op_r_o1, sw.d
	add_d =    			op_r_o1_o2, add.d
	sub_d =    			op_r_o1_o2, sub.d
	mul_d =    			op_r_o1_o2, mul.d
	div_d =    			op_r_o1_o2, div.d
	move_d =    		op_r_o1, mv.d
	mtc1 =    			op_r_o1, mtc
	mfc1 =    			op_r_o1, mfc
	uminus_d =    		op_r_o1, neg.d

%%
/* Values non terminals take */

	stmt = BEGIN
	reg = {r1,r2,r3,r4,r5,r6,r7,r8,r9,r10}
	regf = {f1,f2,f3,f4,f5,f6}
	conditional_goto = {}
	unconditional_goto = {}

%%
/* List of terminals */

	ASSGN, PLUS, MINUS, MULT, DIV,
	UMINUS, LT, GT, NE, GE, LE,
	CON, CONF, ADDR, INT, FLOAT,
	IF, GOTO

%%
/* tree grammar
	cover : node (l-op, r-op) = (cost) {operand corresponding the machine instruction, r, o1, o2} 
	
	$$ - result non terminal
	$1 - left operand 
	$2 - right operand */

	stmt: IF(cndtnl_goto, uncndtnl_goto) = (0)	{no_instruction}

	cndtnl_goto : GOTO(reg , CON) = (1)   {if_else, $1, $zero, $2}
	uncndtnl_goto : GOTO(CON)   = (1)    {goto_type, $1}

	stmt: ASSGN(ADDR,reg)	= (1)	{store, $2, $1}
	stmt: ASSGN(ADDR,regf)	= (1)	{store_d, $2, $1}

	reg: PLUS(reg,reg)	= (1)	{add, $$,$1,$2}
	reg: MINUS(reg,reg)	= (1)	{sub, $$,$1,$2}
	reg: MULT(reg,reg)  = (1)		{mul, $$,$1,$2}
	reg: DIV(reg,reg)	= (1)	{div, $$,$1,$2}
	reg: UMINUS(reg)	= (1)	{uminus, $$,$1}

	regf: PLUS(regf,regf)	= (1)	{add_d, $$,$1,$2}
	regf: MINUS(regf,regf)	= (1)	{sub_d, $$,$1,$2}
	regf: MULT(regf,regf)  	= (1)	{mul_d, $$,$1,$2}
	regf: DIV(regf,regf)	= (1)	{div_d, $$,$1,$2}
	regf: UMINUS(regf)		= (1)	{uminus_d, $$,$1}

	reg: LT(reg,reg)	= (1)	{slt, $$,$1,$2}
	reg: GT(reg,reg)	= (1)	{sgt, $$,$1,$2}
	reg: LE(reg,reg)	= (1)	{sle, $$,$1,$2}
	reg: GE(reg,reg)	= (1)	{sge, $$,$1,$2}
	reg: NE(reg,reg)	= (1)	{sne, $$,$1,$2}
	reg: EQ(reg,reg)	= (1)	{seq, $$,$1,$2}

	reg: CON 	= (1)		{imm_load, $$, $1}
	regf: CONF	= (1)		{load_d, $$, $1}

	regf: FLOAT(reg)	= (1)	{mtc, $$, $1}
	reg: INT(regf)		= (1)	{mfc, $$, $1}

	reg: ADDR 		= (1)	{load, $$, $1}
	regf: ADDR 		= (1)	{load_d, $$, $1}

%%
