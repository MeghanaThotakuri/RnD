
input1:

the input grammar is a small one and the number of available registers are sufficient
output1.cpp and output1_sample2.cpp are generated out of this input file.

running output1.cpp would show the result over a small input tree which is 

	 p = create_tree("ASSGN",
	 		create_tree("ADDR",NULL,NULL,"d"), 
	 		create_tree("PLUS", 
	 			create_tree("CON", NULL,NULL,"a"), 
	 			create_tree("CON", NULL,NULL,"b")));


output1_sample2.cpp does code generation over a bigger tree (store not required yet) and the output can be seen by running it.

	p = create_tree("ASSGN",
			create_tree("ADDR",NULL,NULL,"fp[10]"), 
			create_tree("PLUS", 
				create_tree("PLUS", 
					create_tree("PLUS", 
						create_tree("CON", NULL,NULL,"a"), 
						create_tree("CON", NULL,NULL,"b")), 
					create_tree("PLUS", 
						create_tree("CON", NULL,NULL,"c"), 
						create_tree("CON", NULL,NULL,"d"))),
				create_tree("PLUS", 
					create_tree("PLUS", 
						create_tree("CON", NULL,NULL,"e"), 
						create_tree("CON", NULL,NULL,"f")), 
					create_tree("PLUS", 
						create_tree("CON", NULL,NULL,"g"), 
						create_tree("CON", NULL,NULL,"h")))));



input2:

the input grammar is the same as above but the number of available registers is limited forcing a store in the code generated by the output.

output2.cpp has the code generator for this input, and it furthur takes a input the bigger tree of above example to generate code
It can be observed that a subtree is evaluated first, stored and then the stored value is used later.

	

input3:

This is the big input covering various functionalities.
the output generated for this is in file ouput3.cpp
the input given to the output file is

		p =	create_tree("ADDR",NULL,NULL,"fp[10]"), 
			create_tree("PLUS", 
				create_tree("PLUS", 
					create_tree("PLUS", 
						create_tree("CON", NULL,NULL,"3"), 
						create_tree("CON", NULL,NULL,"4")), 
					create_tree("PLUS", 
						create_tree("ADDR", NULL,NULL,"a"), 
						create_tree("CON", NULL,NULL,"6"))),
				create_tree("UMINUS",
					create_tree("INT",
						create_tree("FLOAT",
							create_tree("ADDR",NULL,NULL,"af"),
							NULL),
						NULL),
					NULL)));



Running the project ::
------------------------

firstly compile the project files to generate an executable using the command

$make 

An executable of name "burg" is formed

The run it with an input grammar

$./burg < inputfilename > outputfilename.cpp

specify the path in case the input file is not in the same directory.

Now in the output file give the input tree and copy the debugging functions from file "(sample cases)\testing data"
copy everything from the file and reply the main function at the end in the output file by the copied stuff

Modify the input tree as required and then compile it and execute

$g++ outputfilename.cpp
$./a.out

